(this["webpackJsonp@stateful/examples"]=this["webpackJsonp@stateful/examples"]||[]).push([[12],{298:function(n,e,t){"use strict";t.r(e),t.d(e,"default",(function(){return u}));var o=t(56),a=t.n(o),i=t(57),s=(t(0),t(26)),r=t(14),l=t(55),c=t(15),d=t(1),m=function(n){return new Promise((function(e){return setTimeout(e,n)}))};function u(){var n=function(){var n=Object(i.a)(a.a.mark((function n(){return a.a.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return n.next=2,m(2e3*Math.random());case 2:if(!(Math.random()>.5)){n.next=4;break}return n.abrupt("return",Promise.reject(new Error("foo")));case 4:case"end":return n.stop()}}),n)})));return function(){return n.apply(this,arguments)}}();return Object(d.jsxs)(d.Fragment,{children:[Object(d.jsx)("h3",{children:"Confirmation examples"}),Object(d.jsxs)("p",{children:["A bunch of different confirm implementations using ",Object(d.jsx)("code",{children:"Stateful"}),"."]}),Object(d.jsxs)("div",{className:"buttons",children:[Object(d.jsxs)(r.Stateful,{confirm:!0,children:[Object(d.jsx)("button",{className:"button",onClick:n,children:"Confirm (exit=started)"}),Object(d.jsx)(r.Stateful.Confirm,{children:Object(d.jsxs)(f,{title:"Default confirm",children:[Object(d.jsxs)("p",{children:["This dialog will disappear immediatly when the user confirms.",Object(d.jsx)("br",{}),"All other states are handled by the original button."]}),Object(d.jsx)("br",{}),Object(d.jsx)("p",{children:"Do you want to proceed?"})]})})]}),Object(d.jsxs)(r.Stateful,{confirm:"onClick",children:[Object(d.jsx)("button",{className:"button",onClick:n,children:"Confirm (exit=finished)"}),Object(d.jsx)(r.Stateful.Confirm,{confirm:"onConfirm",cancel:"onCancel",exit:"finished",children:Object(d.jsxs)(f,{title:"Confirm using exit=finished",children:[Object(d.jsx)("p",{children:"This dialog will stay until the original callback has finished."}),Object(d.jsx)("br",{}),Object(d.jsxs)("p",{children:["The pending and busy states are handled inside this dialog itself.",Object(d.jsx)("br",{}),"However, the success and error states are still handled by the original button."]}),Object(d.jsx)("br",{}),Object(d.jsx)("p",{children:"Do you want to proceed?"})]})})]}),Object(d.jsxs)(r.Stateful,{confirm:"onClick",confirmExit:"idle",provideProps:!1,children:[Object(d.jsx)("button",{className:"button",onClick:n,children:"Confirm (exit=idle)"}),Object(d.jsx)(r.Stateful.Confirm,{children:function(n){var e=n.onCancel,t=n.onConfirm;return Object(d.jsxs)(f,{onConfirm:t,onCancel:e,title:"Confirm using exit=idle",children:[Object(d.jsx)("p",{children:"This confirmation will disappear once the Stateful state switches back to idle."}),Object(d.jsx)("br",{}),Object(d.jsx)("p",{children:"That way, all states including error and success are handled inside the confirmation."}),Object(d.jsx)("p",{children:"Note that you would take extra steps to make sure the buttons are not clickable during error and success states."}),Object(d.jsx)("br",{}),Object(d.jsx)("p",{children:"Do you want to proceed?"})]})}})]}),Object(d.jsx)(r.Stateful,{confirm:!0,children:function(e){var t=e.status,o=e.handlers;return t!==c.Status.CONFIRM?Object(d.jsx)("button",{className:"button",onClick:n,children:"Confirm inline"}):Object(d.jsxs)("div",{className:"field has-addons",children:[Object(d.jsx)("div",{className:"control",children:Object(d.jsx)("button",{className:"button",onClick:o.onConfirmCancel,children:Object(d.jsx)("span",{className:"icon is-small",children:Object(d.jsx)("i",{className:"fas fa-times"})})})}),Object(d.jsx)("div",{className:"control",children:Object(d.jsx)("button",{className:"button",style:{pointerEvents:"none"},children:"Sure?"})}),Object(d.jsx)("div",{className:"control",children:Object(d.jsx)("button",{className:"button is-primary",onClick:o.onConfirmApprove,children:Object(d.jsx)("span",{className:"icon is-small",children:Object(d.jsx)("i",{className:"fas fa-check"})})})})]})}})]}),Object(d.jsx)(l.a,{content:'import React from "react";\nimport { createPortal } from "react-dom";\nimport { Stateful } from "@loopmode/stateful";\nimport { ToggleCodeViewer } from "../../ToggleCodeViewer";\nimport raw from "raw.macro";\nimport { Status } from "@loopmode/stateful/lib/Status";\n\nconst wait = (time: number) => new Promise((resolve) => setTimeout(resolve, time));\n\nexport default function ConfirmExample() {\n  const handleProceed = async () => {\n    await wait(Math.random() * 2000);\n    if (Math.random() > 0.5) {\n      return Promise.reject(new Error("foo"));\n    }\n  };\n  return (\n    <>\n      <h3>Confirmation examples</h3>\n      <p>\n        A bunch of different confirm implementations using <code>Stateful</code>.\n      </p>\n\n      <div className="buttons">\n        {/*\n          In this example, we just wrap a compatible ModalConfirm dialog\n          that supports onCancel and onConfirm props out-of-the-box.\n          Also, we do not specify any custom exit mode, hiding the Stateful.Confirm when the callback is invoked.\n        */}\n        <Stateful confirm>\n          <button className="button" onClick={handleProceed}>\n            Confirm (exit=started)\n          </button>\n          <Stateful.Confirm>\n            <ModalConfirm title="Default confirm">\n              <p>\n                This dialog will disappear immediatly when the user confirms.\n                <br />\n                All other states are handled by the original button.\n              </p>\n              <br />\n              <p>Do you want to proceed?</p>\n            </ModalConfirm>\n          </Stateful.Confirm>\n        </Stateful>\n\n        {/*\n          In this example, we again wrap a dialog, however, we manually assign\n          the names of the dialog props for confirming or aborting via "confirm" and "cancel" props. \n          Also, we use exit mode "finished", hiding the Stateful.Confirm after the callback has finished.\n          Note that the original button displays the same states as the button inside the dialog..\n        */}\n        <Stateful confirm="onClick">\n          <button className="button" onClick={handleProceed}>\n            Confirm (exit=finished)\n          </button>\n          <Stateful.Confirm confirm="onConfirm" cancel="onCancel" exit="finished">\n            <ModalConfirm title="Confirm using exit=finished">\n              <p>This dialog will stay until the original callback has finished.</p>\n              <br />\n              <p>\n                The pending and busy states are handled inside this dialog itself.\n                <br />\n                However, the success and error states are still handled by the original button.\n              </p>\n              <br />\n              <p>Do you want to proceed?</p>\n            </ModalConfirm>\n          </Stateful.Confirm>\n        </Stateful>\n\n        {/*\n          In this example, we use a render function for confirmation. \n\n          Also, we use exit="idle". However, this time we declare it\n          on the Stateful wrapper, where it\'s called "confirmExit" instead of just "exit"\n\n           Note that the original button does not display the because we set "provideProps" to false.\n        */}\n        <Stateful confirm="onClick" confirmExit="idle" provideProps={false}>\n          <button className="button" onClick={handleProceed}>\n            Confirm (exit=idle)\n          </button>\n          <Stateful.Confirm>\n            {({ onCancel, onConfirm }) => {\n              return (\n                <ModalConfirm\n                  onConfirm={onConfirm}\n                  onCancel={onCancel}\n                  title="Confirm using exit=idle"\n                >\n                  <p>\n                    This confirmation will disappear once the Stateful state switches back to idle.\n                  </p>\n                  <br />\n                  <p>\n                    That way, all states including error and success are handled inside the\n                    confirmation.\n                  </p>\n                  <p>\n                    Note that you would take extra steps to make sure the buttons are not clickable\n                    during error and success states.\n                  </p>\n                  <br />\n                  <p>Do you want to proceed?</p>\n                </ModalConfirm>\n              );\n            }}\n          </Stateful.Confirm>\n        </Stateful>\n\n        {/*\n          In this example, we build an inline confirmation without using a modal dialog at all.\n          We use a render function to have completely different components depending on the status.\n        */}\n        <Stateful confirm>\n          {({ status, handlers }) => {\n            if (status !== Status.CONFIRM) {\n              // the regular button\n              return (\n                <button className="button" onClick={handleProceed}>\n                  Confirm inline\n                </button>\n              );\n            }\n            // confirm state with different components\n            return (\n              <div className="field has-addons">\n                <div className="control">\n                  <button className="button" onClick={handlers.onConfirmCancel}>\n                    <span className="icon is-small">\n                      <i className="fas fa-times"></i>\n                    </span>\n                  </button>\n                </div>\n                <div className="control">\n                  <button className="button" style={{ pointerEvents: "none" }}>\n                    Sure?\n                  </button>\n                </div>\n                <div className="control">\n                  <button className="button is-primary" onClick={handlers.onConfirmApprove}>\n                    <span className="icon is-small">\n                      <i className="fas fa-check"></i>\n                    </span>\n                  </button>\n                </div>\n              </div>\n            );\n          }}\n        </Stateful>\n      </div>\n\n      <ToggleCodeViewer content={raw("./confirm-example.tsx")} />\n    </>\n  );\n}\n\ntype ModalConfirmProps = {\n  title?: string;\n  // onCancel and onConfirm are supported out of the box\n  onCancel?: () => void;\n  onConfirm?: () => void;\n};\nfunction ModalConfirm(props: React.PropsWithChildren<ModalConfirmProps>) {\n  return createPortal(\n    <div className="modal is-active">\n      <div className="modal-background"></div>\n      <div className="modal-card">\n        {props.title && (\n          <header className="modal-card-head">\n            <div className="modal-card-title">{props.title}</div>\n            <button className="delete" aria-label="close" onClick={props.onCancel}></button>\n          </header>\n        )}\n        <section className="modal-card-body">{props.children}</section>\n        <footer className="modal-card-foot">\n          <button className="button" onClick={props.onCancel}>\n            Cancel\n          </button>\n          <span style={{ flex: 1 }} />\n          <Stateful.Consumer>\n            <button className="button is-info" onClick={props.onConfirm}>\n              Proceed\n            </button>\n          </Stateful.Consumer>\n        </footer>\n      </div>\n    </div>,\n    document.body\n  );\n}\n'})]})}function f(n){return Object(s.createPortal)(Object(d.jsxs)("div",{className:"modal is-active",children:[Object(d.jsx)("div",{className:"modal-background"}),Object(d.jsxs)("div",{className:"modal-card",children:[n.title&&Object(d.jsxs)("header",{className:"modal-card-head",children:[Object(d.jsx)("div",{className:"modal-card-title",children:n.title}),Object(d.jsx)("button",{className:"delete","aria-label":"close",onClick:n.onCancel})]}),Object(d.jsx)("section",{className:"modal-card-body",children:n.children}),Object(d.jsxs)("footer",{className:"modal-card-foot",children:[Object(d.jsx)("button",{className:"button",onClick:n.onCancel,children:"Cancel"}),Object(d.jsx)("span",{style:{flex:1}}),Object(d.jsx)(r.Stateful.Consumer,{children:Object(d.jsx)("button",{className:"button is-info",onClick:n.onConfirm,children:"Proceed"})})]})]})]}),document.body)}},55:function(n,e,t){"use strict";t.d(e,"a",(function(){return l}));var o=t(10),a=t(58),i=t(0),s=t.n(i),r=t(1);function l(n){var e=n.language,t=void 0===e?"jsx":e,i=n.content,l=s.a.useState(!1),c=Object(o.a)(l,2),d=c[0],m=c[1];return Object(r.jsxs)(r.Fragment,{children:[Object(r.jsx)("hr",{}),Object(r.jsxs)("a",{href:"#",onClick:function(){return m(!d)},children:[d?"Hide":"Show"," code"]}),d&&Object(r.jsx)(a.a,{language:t,children:i})]})}}}]);
//# sourceMappingURL=12.f9f7fd93.chunk.js.map
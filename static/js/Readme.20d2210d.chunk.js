(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{355:function(e,t,n){e.exports={Markdown:"_3HAAgi00lfs4qIw3St0ANt"}},48:function(e,t,n){"use strict";n.r(t),n.d(t,"loadDependencies",function(){return h}),n.d(t,"default",function(){return y});var a=n(98),s=n(99),o=n(114),r=n(100),i=n(113),l=n(81),p=n.n(l),u=n(82),c=n(0),d=n.n(c),m=n(5),f=n.n(m),h=function(){var e=Object(u.a)(p.a.mark(function e(){var t,a;return p.a.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,n.e(9).then(n.t.bind(null,110,7));case 2:return t=e.sent,e.next=5,n.e(10).then(n.t.bind(null,111,7));case 5:return e.next=7,n.e(1).then(n.t.bind(null,58,7));case 7:return e.next=9,n.e(1).then(n.t.bind(null,58,7));case 9:return e.next=11,n.e(11).then(n.t.bind(null,112,7));case 11:return a=e.sent,e.abrupt("return",{Prism:t,ReactPrism:a});case 13:case"end":return e.stop()}},e)}));return function(){return e.apply(this,arguments)}}(),b=d.a.lazy(Object(u.a)(p.a.mark(function e(){var t,n;return p.a.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,h();case 2:return t=e.sent,n=t.ReactPrism,e.abrupt("return",n);case 5:case"end":return e.stop()}},e)}))),y=function(e){function t(){return Object(a.a)(this,t),Object(o.a)(this,Object(r.a)(t).apply(this,arguments))}return Object(i.a)(t,e),Object(s.a)(t,[{key:"render",value:function(){return d.a.createElement(b,{component:"pre",className:f()("Code push","language-".concat(this.props.lang.toLowerCase()))},this.props.children)}}]),t}(d.a.Component);y.defaultProps={lang:"jsx"}},51:function(e,t,n){e.exports={PrevNextLinks:"_1O7WOT8zYg7oZ7IIhDdvoR"}},54:function(e,t,n){"use strict";var a=n(80),s=n(0),o=n.n(s),r=n(298),i=n(643),l=n(51),p=n.n(l),u=n(5),c=n.n(u),d=Object(i.a)(function(e){var t=function(e,t){var n=Object(a.a)(e).findIndex(function(e){return e.hash.replace("#","")===t}),s=e[n-1],o=s&&{to:s.hash.replace("#",""),children:"\u25c0 ".concat(s.innerHTML)},r=e[n+1],i=r&&{to:r.hash.replace("#",""),children:"".concat(r.innerHTML," \u25b6")};return{prevLink:o,nextLink:i}}(document.querySelectorAll(".AppMenu a"),e.location.pathname),n=t.prevLink,s=t.nextLink;return o.a.createElement("footer",{className:c()("PrevNextLinks",p.a.PrevNextLinks)},n&&o.a.createElement(r.a,Object.assign({},n,{onClick:m})),o.a.createElement("span",{className:"spacer"}),s&&o.a.createElement(r.a,Object.assign({},s,{onClick:m})))});function m(){document.documentElement.scrollTop=0}n.d(t,"a",function(){return d})},662:function(e,t,n){"use strict";n.r(t);var a=n(0),s=n.n(a),o=n(81),r=n.n(o),i=n(82),l=n(148),p=n(302),u=n.n(p),c=n(355),d=n.n(c),m=n(5),f=n.n(m),h=function(e){var t=e.className,a=Object(l.a)(e,["className"]),o=s.a.useRef();return function(e){var t=n(48).loadDependencies,a=function(){var n=Object(i.a)(r.a.mark(function n(){var a,s;return r.a.wrap(function(n){for(;;)switch(n.prev=n.next){case 0:return n.next=2,t();case 2:a=n.sent,s=a.Prism,e?e.current&&s.highlightAllUnder(e.current):s.highlightAll();case 5:case"end":return n.stop()}},n)}));return function(){return n.apply(this,arguments)}}();s.a.useEffect(function(){a()})}(o),s.a.createElement("div",{className:f()("Markdown",d.a.Markdown,t),ref:o},s.a.createElement(u.a,a))};var b=n(54);t.default=function(e){return s.a.createElement(s.a.Fragment,null,s.a.createElement(h,Object.assign({},e,{className:"Readme",source:"# @loopmode/stateful\n\nA react component for visual indication of async state.\n\n![success gif](https://github.com/loopmode/stateful/raw/master/stateful-success.gif 'Example of loading and success indication')\n![error gif](https://github.com/loopmode/stateful/raw/master/stateful-error.gif 'Example of loading and error indication')\n\nThis is an unobtrusive wrapper component that doesn't require any significant changes in your existing code.\n\nSee also:\n\n-   [docs and examples](https://loopmode.github.io/stateful/)\n-   [npm page](https://www.npmjs.com/package/@loopmode/stateful)\n\n## Installation\n\nUsing npm:\n\n```bash\nnpm install --save @loopmode/stateful\n```\n\nUsing yarn:\n\n```bash\nyarn add @loopmode/stateful\n```\n\n## Usage\n\nJust wrap it around a component that has a callback. If the callback returns a promise, the wrapped component will receive props that indicate the state of the promise.\n\n```jsx\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport Stateful from '@loopmode/stateful';\n\nfunction handleClick() {\n    return fetch('https://jsonplaceholder.typicode.com/users');\n}\nconst Demo = () => (\n    <Stateful>\n        <button onClick={handleClick}>load</button>\n    </Stateful>\n);\nReactDOM.render(<Demo />, document.getElementById('root'));\n```\n\nIn the example above, we used `<Stateful>` without any props, falling back to the default configuration.\n\nThe wrapped button will\n\n-   have a `disabled` prop when clicked, and until the promise is resolved or rejected\n-   have a `busy` CSS class right away - after `busyDelay` milliseconds (default `0`)\n-   have a `success` CSS class for `successDuration` milliseconds (default `1000`) when the promise is resolved\n-   have an `error` CSS class for `errorDuration` milliseconds (default `1000`) when the promise is rejected\n\n## Supported props\n\n| Prop           | Type     | Default                           | Description                                                                                             |\n| -------------- | -------- | --------------------------------- | ------------------------------------------------------------------------------------------------------- |\n| callbacks      | PolyType | `['onClick']`                     | Names of callbacks to intercept and check for promises                                                  |\n| pendingProps   | PolyType | `['disabled']`                    | Names of props to add for `Status.PENDING`                                                              |\n| pendingClasses | PolyType | `[]`                              | Names of CSS classes to add for `Status.PENDING`                                                        |\n| busyProps      | PolyType | `['disabled']`                    | Names of props to add for `Status.BUSY`                                                                 |\n| busyClasses    | PolyType | `[]`                              | Names of CSS classes to add for `Status.BUSY`                                                           |\n| errorProps     | PolyType | `[]`                              | Names of props to add for `Status.ERROR`                                                                |\n| errorClasses   | PolyType | `['error']`                       | Names of CSS classes to add for `Status.ERROR`                                                          |\n| successProps   | PolyType | `[]`                              | Names of props to add for `Status.SUCCESS`                                                              |\n| successClasses | PolyType | `['success']`                     | Names of CSS classes to add for `Status.SUCCESS`                                                        |\n| hintDuration   | Number   | `1000`                            | Duration in milliseconds for `Status.SUCCESS` and `Status.ERROR` before returning to the default status |\n| busyDelay      | Number   | `0`                               | Duration in milliseconds to wait after `Status.PENDING` and before `Status.BUSY`                        |\n| delimiter      | String   | `' '`                             | Delimiter for splitting `PolyType` props of type `String` into multiple values                          |\n| rejectValue    | Function | `value => value instanceof Error` | Whether to indicate `Status.ERROR` for a promise that was actually resolved with a value                |\n\nThe term \"PolyType\" isn't the latest thing, it's just something I made up for the sakes of this documentation, see details below.\n\n```jsx\nconst PolyType = PropTypes.oneOfType([\n    PropTypes.string,\n    PropTypes.arrayOf(PropTypes.string),\n    PropTypes.func\n]);\n```\n\n### PolyType: String\n\nIn most cases, you can stick with the `String` type. It supports both single and multiple values, but in a primitive type that works well with pure components.\nSingle values are typed as a simple string, while multiple values are delimiter-separated strings. The default delimiter is a space (``), but you can change that using the `delimiter` prop.\n\n```jsx\n<Stateful pendingProps=\"disabled\" />\n<Stateful pendingProps=\"disabled pending\" />\n<Stateful pendingProps=\"disabled,pending\" delimiter=\",\" />\n```\n\n### PolyType: Array\n\nIn some cases, it might be preferrable to provide the props as an array. While this interferes with rendering of pure components when typed inline, in many cases you do have an array that you can pass on directly.\n\n```jsx\n<Stateful pendingProps={['disabled']} />\n<Stateful pendingProps={['disabled', 'pending']} />\n<Stateful pendingProps={myPropsArray} />\n```\n\n### PolyType: Function\n\nSometimes, the component you need to wrap just doesn't support a simple boolean flag to get the job done. For example, `react-bootstraps` wants to receive `variant=\"success\"` or `variant=\"danger\"` - the same prop, but with a different value.\nIn these cases, you can provide a function that receives the current `status` and returns an object with as many properties and values as needed.\n\n```jsx\n<Stateful\n    pendingProps={() => ({ status: 'pending' })}\n    successProps={() => ({ status: 'success' })}\n/>\n```\n\n## Internal state: `status`\n\nInternally, we use a variable named `status` to handle the current state. Its value is just an integer, all possible values are defined in [Status](https://github.com/loopmode/stateful/blob/master/packages/stateful/src/Status.js).\n\n| status         | value | Description                                                                                                                          |\n| -------------- | ----- | ------------------------------------------------------------------------------------------------------------------------------------ |\n| Status.IDLE    | `0`   | The default state - no props are added to wrapped children                                                                           |\n| Status.PENDING | `1`   | A callback was invoked, and it returned a promise. Wrapped children now receive `pendingProps` and `pendingClasses`                  |\n| Status.BUSY    | `2`   | The returned promise has been pending for more than `busyDelay` milliseconds. Wrapped children receive `busyProps` and `busyClasses` |\n| Status.SUCCESS | `3`   | The returned promise was resolved. Wrapped children receive `successProps` and `successClasses` for `successDuration` milliseconds   |\n| Status.ERROR   | `4`   | The returned promise was rejected. Wrapped children receive `errorProps` and `errorClasses` for `errorDuration` milliseconds         |\n\nWhen you provide a function value to a PolyType prop, that function will be invoked with the current `status` as its first argument.\nYou can import the named values via `import { Status } from '@loopmode/stateful'` or `import * as Status from '@loopmode/stateful/lib/Status'` to compare against them.\n\n```jsx\n<Stateful\n    pendingProps={status => {\n        console.log({ status });\n        return {\n            status,\n            foo: 'bar',\n            bar: 'baz'\n        };\n    }}\n/>\n```\n\n## Usage with UI libraries and frameworks\n\nMost UI libraries and frameworks come prepared for these situations and provide class names or props to make a button look green or red or busy.\nWhile `@loopmode/stateful` makes it easy to write a custom wrapper for any library you use, it comes with a couple of presets for popular frameworks.\n(Suggestions and especially pull requests for more support are highly welcome!)\n\nTo use the pre-configured wrapper components, you should import them specifically from `lib/wrapper`.\nIdeally, you would do this only once for the local `Stateful` component of a project, configure it there, and import that one across your codebase.\n\n| name        | examples                                                    | implementation                                                                                                            | usage                                                                 |\n| ----------- | ----------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------- |\n| antd        | [example](http://loopmode.github.io/stateful/#/antd)        | [wrappers/antd.js](https://github.com/loopmode/stateful/blob/master/packages/stateful/src/wrappers/antd.js)               | `import Stateful from '@loopmode/stateful/lib/wrappers/antd';`        |\n| bootstrap   | [example](http://loopmode.github.io/stateful/#/bootstrap)   | [wrappers/bootstrap.js](https://github.com/loopmode/stateful/blob/master/packages/stateful/src/wrappers/bootstrap.js)     | `import Stateful from '@loopmode/stateful/lib/wrappers/bootstrap';`   |\n| semantic-ui | [example](http://loopmode.github.io/stateful/#/semantic-ui) | [wrappers/semantic-ui.js](https://github.com/loopmode/stateful/blob/master/packages/stateful/src/wrappers/semantic-ui.js) | `import Stateful from '@loopmode/stateful/lib/wrappers/semantic-ui';` |\n| material-ui | [example](http://loopmode.github.io/stateful/#/material-ui) | -                                                                                                                         | -                                                                     |\n\n### Recommended usage\n\nYou might be able to use one of the pre-configured library wrappers, but chances are you'll need your own wrapper.\nTypically, you should create a local `components/Stateful` component, configure it once for the needs of your project, and pass along the rest of the props.\n\n```jsx\n// src/components/Stateful/index.js\n\nimport React from 'react';\nimport DefaultStateful from '@loopmode/stateful';\n\nconst CustomStateful = props => {\n    return (\n        <DefaultStateful\n            // whatever suits your project\n            pendingProps=\"disabled\"\n            pendingClasses=\"loading\"\n            errorProps={null}\n            errorClasses=\"danger\"\n            successProps={null}\n            successClasses=\"success\"\n            busyDelay={250}\n            {...props}\n        />\n    );\n};\n\nexport default CustomStateful;\n```\n\nThis makes it easy to use the component, but it still leaves you lots of flexibility.\nYou can still pass props, but you don't have to.\n\nThis is how you would then use it:\n\n```jsx\nimport Page from 'components/Page';\nimport UpdateForm from 'components/Form/UpdateForm';\nimport Button from 'components/Button';\nimport Stateful from 'components/Stateful';\n\nconst UpdatePage = props => (\n    <Page>\n        <h2>Update details</h2>\n        <UpdateForm data={props.formData} onChange={props.onFormChange} />\n        <Stateful busyDelay={500}>\n            <Button onClick={props.onFormSubmit} children=\"Create\" />\n        </Stateful>\n    </Page>\n);\n\nexport default UpdatePage;\n```\n\nCheck out [the default wrappers](https://github.com/loopmode/stateful/tree/master/packages/stateful/src/wrappers) for some examples using this approach.\n",options:{html:!0}})),s.a.createElement(b.a,null))}}}]);
//# sourceMappingURL=Readme.20d2210d.chunk.js.map